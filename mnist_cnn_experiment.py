# -*- coding: utf-8 -*-
"""1.1 and 1.2 best

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1BOI08ReCmSolnlBnWTJtSToLdyZaaf53
"""

import tensorflow as tf
import numpy as np
import matplotlib.pyplot as plt
from tensorflow import keras
from tensorflow.keras.layers import Input, Dense, Flatten, Conv2D, MaxPooling2D, AveragePooling2D


mnist=tf.keras.datasets.mnist
(x_train, y_train), (x_test, y_test) = mnist.load_data()
#60000 mokymui, 10000 testavimui

# 15-os paveiksliukų atvaizadaviams iš mokymo aibės
plt.figure(figsize=(10,5)) # vieno paveiksliuko matmenys
for i in range(15):  # rodomų paveiksliukų kiekis
  plt.subplot(3,5,i+1) # paveiksliukų atvaizdavimas, eilučių ir stulpelių kiekis
  plt.xticks([]) # nustato žymas x ašyje
  plt.yticks([]) # nustato žymas y ašyje
  plt.imshow(x_train[i], cmap=plt.cm.binary) #cmap=plt.cm.binary - pilkos spalvos (Kitos spalvos: cmap=plt.cm.RdYlGn; cmap=plt.cm.Blues; cmap=plt.cm.autumn, cmap=plt.cm.Green ...  )
  #https://chrisalbon.com/code/python/basics/set_the_color_of_a_matplotlib/
plt.show()

# Įeinamų duomenų normalizacija, kad pikselio reikšmė būtų nuo 0 iki 1. Daliname iš didžiausio galima skaičiaus 255.
x_train=x_train/255
x_test=x_test/255

# Požymio reikšmės pakeitimas į vektorių, pvz. 2 -> {0,0,1,0,0,0,0,0,0,0}
y_train2=keras.utils.to_categorical(y_train,10)
y_test2=keras.utils.to_categorical(y_test,10)

# Modelio kūrimas
model=keras.Sequential([
                        Input(shape=(28, 28, 1)),   #(batch_size, 28, 28, 1)
                        # 64 - filtru branduoliu skaicius
                        #3,3 - filtro dydis (mazas langelis slenktantis per vaizda, matricos dydis)
                        #relu - leidzia tinklui mokytis sudetingesniu funkciju
                        Conv2D(64, (3,3), padding='same', activation='relu'), # naudoja (batch_size, 28, 28, 32) tenzorių; istraukia pozymius is vaizdo
                        #2,2 - apskaiciuoja vidurki arba randa maximuma toje erdveje
                        #strides - zingsniai - kiek piskeliu judame
                        AveragePooling2D((2,2), strides=3), #sumazina informacijos kieki
                        Conv2D(64, (3,3), padding='same', activation='relu'), # relu suteikia nelinijiskuma, leidzia tinklui mokytis sudetingesniu funkciju
                        AveragePooling2D((2,2), strides=3), #(batch_size, 7, 7, 64)
                        Flatten(), #(batch_size, 3136) #sulygina duomenis
                        Dense(100, activation='relu'), #mokosi derinti pozymius
                        Dense(10, activation='softmax') #softmax - tikimybe
])
print(model.summary()) # išveda modelio aprašymą

# Automatiškai generuojamas neur. tinklas su pradiniais svoriaias
opt = keras.optimizers.Adam(learning_rate=0.01)
model.compile(optimizer=opt, #'sgd',
              # Gradientiai metodai: 'sgd', 'rmsprop', 'adam'
              loss='categorical_crossentropy',
              metrics=['accuracy'] )

# Neur. tinklo apmokymas
mokymo=model.fit(x_train, y_train2, batch_size=32, epochs=6, validation_split=0.2)
# batch - po kiekvienų iš 32 vaizdų koreaguosime svorius;
# epoch - ciklai
# validation - mokymo aibės išskaidymas į mokymo-patikrinimo

testo=model.evaluate(x_test,y_test2)

plt.plot(mokymo.history['accuracy'])
plt.plot(mokymo.history['val_accuracy'])
plt.legend(['mokymo', 'validavimo'])
plt.title('Modelio tikslumas')
plt.legend(['mokymo', 'validavimo'], loc='upper left')
plt.show()

plt.plot(mokymo.history['loss'])
plt.plot(mokymo.history['val_loss'])
plt.title('Modelio loss funkcija')
plt.xlabel('epoch')
plt.ylabel('loss')
plt.legend(['mokymo', 'validavimo'], loc='upper left')
plt.show()

n=5 # pirmas vaizdas
x=np.expand_dims(x_test[n], axis=0) # išplėčia masyvą,
spr=model.predict(x)
print(spr) # išveda reikšmių vektorių
print(f"Skaičius: {np.argmax(spr)}") # išveda didžiausio skaičiaus eilės numerį, argumentą

plt.imshow(x_test[n], cmap=plt.cm.binary)
plt.show()

pred=model.predict(x_test)
pred=np.argmax(pred, axis=1)

print(pred.shape)

print(pred[:20])
print(y_test[:20])

mask=pred==y_test
print(mask[:10])

x_false=x_test[~mask]
p_false=pred[~mask]

print(x_false.shape)

for i in range(5):
   print("Reikšmė ="+str(y_test[i]))
   plt.imshow(x_false[i], cmap=plt.cm.binary)
   plt.show()


# Import the necessary libraries
from PIL import Image
from numpy import asarray


# load the image and convert into

# PIL images into NumPy arrays
image= Image.open("Sample7.png")
img = image.convert('L') # vaizdo konvertavimas į pilkos spalvos skalę
numpydata = asarray(img)

numpydata=numpydata/255
# <class 'numpy.ndarray'>
print(type(numpydata))

#  shape
print(numpydata.shape)

x=np.expand_dims(numpydata, axis=0) # išplėčia masyvą, (1, 28, 28)
spr=model.predict(x)
print(np.round(spr,3)) # išveda reikšmių vektorių
print(f"Skaičius: {np.argmax(spr)}") # išveda didžiausio skaičiaus eilės numerį, argumentą

plt.imshow(numpydata, cmap=plt.cm.binary)
plt.show()